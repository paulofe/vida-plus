<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>9x9 • Múltiplos de 9 v1.4 (single-file)</title>
<style>
  :root { color-scheme: dark; }
  html,body { margin:0; height:100%; background:#0d0f12; color:#e8e8e8; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }

  /* Canvas ocupa toda a viewport dinâmica; overlays não ocupam layout */
  #game {
    display:block; width:100vw; height:100dvh; background:#0a0c0f; touch-action:none;
  }

  /* Overlays fixos por cima do canvas */
  .overlay {
    position:fixed; left:0; right:0; z-index:10; pointer-events:auto;
    padding:6px 10px; background:#121418cc; backdrop-filter:saturate(120%) blur(6px);
    border-bottom:1px solid #1f232a;
  }
  #top { top:0; display:flex; align-items:center; justify-content:space-between; gap:10px; }
  #bottom {
    bottom:0; border-top:1px solid #1f232a; border-bottom:none;
    padding-bottom:calc(6px + env(safe-area-inset-bottom, 0px));
    text-align:center; font-size:12px; opacity:.9;
  }

  .hud { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .pill { background:#171a20; border:1px solid #2a2f39; border-radius:999px; padding:3px 8px; font-variant-numeric: tabular-nums; }
  #title { font-weight:600; }
  #ver { opacity:.8; font-size:12px; padding-left:6px; }
  button { background:#1f6feb; color:#fff; border:0; border-radius:8px; padding:6px 10px; cursor:pointer; }
  button:active { filter:brightness(.9) }

  @media (min-width: 960px){
    #top, #bottom { left:50%; right:auto; transform:translateX(-50%); width:min(1024px, 100vw); }
  }
</style>
</head>
<body>

<canvas id="game" width="960" height="960" aria-label="Tabuleiro 9x9"></canvas>

<div id="top" class="overlay">
  <div style="display:flex; align-items:center;">
    <div id="title">9x9 • Múltiplos de 9</div><div id="ver">v1.4</div>
  </div>
  <div class="hud">
    <span class="pill">Soma: <b id="sum">0</b></span>
    <span class="pill">Soma % 9: <b id="mod">0</b></span>
    <span class="pill">Sel.: <b id="count">0</b></span>
    <span class="pill">Remov.: <b id="removed">0</b></span>
    <button id="restart">Reiniciar</button>
  </div>
</div>

<div id="bottom" class="overlay">
  Regra: conecte peças <b>adjacentes ortogonalmente</b>. Quando a <b>soma</b> for um <b>múltiplo de 9</b>, as peças <b>somem</b>. Sem gravidade.
</div>

<script type="module">
// ===== v1.4 — single-file, mobile-fit real =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });

const sumEl = document.getElementById('sum');
const modEl = document.getElementById('mod');
const countEl = document.getElementById('count');
const removedEl = document.getElementById('removed');
const btnRestart = document.getElementById('restart');
const topBar = document.getElementById('top');
const bottomBar = document.getElementById('bottom');

const GRID = 9;
const VALUES = { min:1, max:8 };
const PADDING = 20; // padding interno em torno do tabuleiro

const state = {
  grid: [],
  selected: [],
  removed: 0,
  sum: 0,
  dragging: false,
};

// ---------- helpers ----------
const randInt = (a,b)=> Math.floor(a + Math.random()*(b-a+1));
const inBounds = (r,c)=> r>=0 && r<GRID && c>=0 && c<GRID;
const isEmpty  = (r,c)=> state.grid[r][c] === 0;
const areAdj   = (a,b)=> Math.abs(a.r-b.r) + Math.abs(a.c-b.c) === 1;
const alreadySelected = (rc)=> state.selected.some(p=>p.r===rc.r && p.c===rc.c);

function safeHeights(){
  // mede overlays reais para "reservar" espaço do tabuleiro
  const topH = topBar.getBoundingClientRect().height;
  const botH = bottomBar.getBoundingClientRect().height;
  return { topH, botH };
}

function cssViewport(){
  // usa visualViewport se disponível para lidar com barras dinâmicas
  const vv = window.visualViewport;
  return {
    w: (vv?.width)  || window.innerWidth,
    h: (vv?.height) || window.innerHeight
  };
}

function resize(){
  const { w, h } = cssViewport();
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  // Canvas preenche a viewport inteira
  canvas.style.width  = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width  = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  draw();
}

function cellSize(){
  // calcula área útil descontando overlays
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const w = canvas.width  / dpr;
  const h = canvas.height / dpr;
  const { topH, botH } = safeHeights();
  const usableW = w - PADDING*2;
  const usableH = h - topH - botH - PADDING*2;
  return Math.max(8, Math.floor(Math.min(usableW, usableH) / GRID));
}

function boardOrigin(){
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const w = canvas.width  / dpr;
  const h = canvas.height / dpr;
  const { topH, botH } = safeHeights();
  const size = cellSize() * GRID;
  const x0 = Math.floor((w - size) / 2);
  const y0 = Math.floor((h - topH - botH - size) / 2) + topH;
  return { x0, y0, size };
}

function cellRect(r,c){
  const s = cellSize();
  const { x0, y0 } = boardOrigin();
  const x = x0 + c*s, y = y0 + r*s;
  return { x, y, w:s, h:s, cx:x+s/2, cy:y+s/2 };
}

function pointToCell(px, py){
  const { x0, y0, size } = boardOrigin();
  const s = cellSize();
  if (px < x0 || py < y0 || px >= x0+size || py >= y0+size) return null;
  const c = Math.floor((px - x0)/s);
  const r = Math.floor((py - y0)/s);
  return inBounds(r,c) ? { r,c } : null;
}

// ---------- game logic ----------
function initGrid(){
  state.grid = Array.from({length:GRID},()=> Array.from({length:GRID},()=> randInt(VALUES.min, VALUES.max)));
  state.removed = 0;
  clearSelection();
  draw(); syncHud();
}
function clearSelection(){ state.selected.length=0; state.sum=0; syncHud(); }

function tryAddToSelection(rc){
  if (!inBounds(rc.r,rc.c) || isEmpty(rc.r,rc.c)) return;
  if (state.selected.length === 0){
    state.selected.push(rc); state.sum += state.grid[rc.r][rc.c];
  } else {
    const last = state.selected[state.selected.length-1];
    if (state.selected.length >= 2){
      const prev = state.selected[state.selected.length-2];
      if (prev.r===rc.r && prev.c===rc.c){
        const popped = state.selected.pop();
        state.sum -= state.grid[popped.r][popped.c];
        syncHud(); draw(); return;
      }
    }
    if (areAdj(last, rc) && !alreadySelected(rc)){
      state.selected.push(rc); state.sum += state.grid[rc.r][rc.c];
    }
  }
  syncHud();
}

function commitIfValid(){
  if (state.selected.length===0) return false;
  if (state.sum % 9 === 0){
    for (const p of state.selected){
      if (state.grid[p.r][p.c] !== 0){ state.grid[p.r][p.c]=0; state.removed++; }
    }
    clearSelection(); return true;
  } else { clearSelection(); return false; }
}

function syncHud(){
  sumEl.textContent = state.sum;
  modEl.textContent = state.sum % 9;
  countEl.textContent = state.selected.length;
  removedEl.textContent = state.removed;
}

// ---------- drawing ----------
function draw(){
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  ctx.save(); ctx.scale(dpr,dpr);

  const w = canvas.width/dpr, h = canvas.height/dpr;
  ctx.fillStyle = '#0b0d11'; ctx.fillRect(0,0,w,h);

  const s = cellSize();
  const { x0, y0 } = boardOrigin();
  const boardW = s*GRID, boardH = s*GRID;

  // board panel
  ctx.fillStyle = '#0f1318';
  ctx.fillRect(x0-4, y0-4, boardW+8, boardH+8);

  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.font = Math.floor(s*0.42) + 'px system-ui';

  const isSel = (r,c)=> state.selected.some(p=>p.r===r&&p.c===c);

  for (let r=0;r<GRID;r++){
    for (let c=0;c<GRID;c++){
      const val = state.grid[r][c];
      const {x,y,w:sw,h:sh,cx,cy} = cellRect(r,c);
      ctx.fillStyle = isSel(r,c) ? '#214367' : (val===0 ? '#141920' : '#151b23');
      ctx.fillRect(x+1, y+1, sw-2, sh-2);

      ctx.strokeStyle = '#243041'; ctx.lineWidth = 1;
      ctx.strokeRect(x+0.5, y+0.5, sw-1, sh-1);

      if (val !== 0){
        ctx.fillStyle = ['','#a6e3a1','#94e2d5','#89b4fa','#f9e2af','#fab387','#eba0ac','#cba6f7','#f38ba8'][val];
        ctx.fillText(String(val), cx, cy);
      } else {
        ctx.fillStyle = 'rgba(255,255,255,.06)';
        ctx.beginPath(); ctx.arc(cx, cy, Math.max(2, s*0.04), 0, Math.PI*2); ctx.fill();
      }
    }
  }

  if (state.selected.length>0){
    ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.lineWidth = Math.max(2, s*0.06);
    ctx.lineJoin = 'round'; ctx.lineCap = 'round'; ctx.beginPath();
    for (let i=0;i<state.selected.length;i++){
      const {cx,cy} = cellRect(state.selected[i].r, state.selected[i].c);
      if (i===0) ctx.moveTo(cx,cy); else ctx.lineTo(cx,cy);
    }
    ctx.stroke();
  }

  // hint
  ctx.fillStyle = 'rgba(255,255,255,.12)'; ctx.font='12px system-ui'; ctx.textAlign='left';
  ctx.fillText('Arraste para selecionar. Solte para validar.', x0, y0 - 10);

  ctx.restore();
}

// ---------- input ----------
function canvasPoint(evt){
  const rect = canvas.getBoundingClientRect();
  let x, y;
  if (evt.touches?.length){
    x = evt.touches[0].clientX - rect.left;
    y = evt.touches[0].clientY - rect.top;
  } else {
    x = (evt.clientX ?? 0) - rect.left;
    y = (evt.clientY ?? 0) - rect.top;
  }
  // converte CSS px -> px lógicos, depois corrige para dpr
  const cssW = rect.width, cssH = rect.height;
  const scaleX = canvas.width / cssW, scaleY = canvas.height / cssH;
  const px = x * scaleX, py = y * scaleY;
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  return { x: px/dpr, y: py/dpr };
}

function onDown(e){ e.preventDefault(); state.dragging=true; const pt=canvasPoint(e); const cell=pointToCell(pt.x, pt.y); if(cell){ clearSelection(); tryAddToSelection(cell); draw(); } }
function onMove(e){ if(!state.dragging) return; e.preventDefault(); const pt=canvasPoint(e); const cell=pointToCell(pt.x, pt.y); if(cell){ tryAddToSelection(cell); draw(); } }
function onUp(e){ if(!state.dragging) return; e.preventDefault(); state.dragging=false; commitIfValid(); draw(); }

canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive:false});
canvas.addEventListener('touchmove',  onMove, {passive:false});
canvas.addEventListener('touchend',   onUp,   {passive:false});

btnRestart.addEventListener('click', initGrid);

// ---------- boot & reactive resize ----------
function doResize(){ resize(); }
window.addEventListener('resize', doResize);
if (window.visualViewport) window.visualViewport.addEventListener('resize', doResize);

// se HUD quebrar de linha (mudou altura), redesenha
const ro = new ResizeObserver(()=> draw());
ro.observe(topBar); ro.observe(bottomBar);

function boot(){ resize(); initGrid(); }
boot();
</script>
</body>
</html>